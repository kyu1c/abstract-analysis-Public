import { db, firebaseConfig } from "@/lib/firebase";
import { collection, addDoc, getDocs, query, where, writeBatch, doc, setDoc } from "firebase/firestore";
import { initializeApp, getApps, getApp, deleteApp } from "firebase/app";
import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut } from "firebase/auth";

// ==========================================
// DATA EDITING SECTION
// ==========================================
// You can freely add, remove, or modify papers in the list below.
// The 'abstract' field is where the text content lives.
const PAPERS = [
    {
        title: "AACessTalk : Fostering Communication between Minimally Verbal Autistic Children and Parents with Contextual Guidance and Card Recommendation",
        abstract: "As minimally verbal autistic (MVA) children communicate with parents through few words and nonverbal cues, parents often struggle to encourage their children to express subtle emotions and needs and to grasp their nuanced signals. We present AACessTalk, a tablet-based, AI-mediated communication system that facilitates meaningful exchanges between an MVA child and a parent. AACessTalk provides real-time guides to the parent to engage the child in conversation and, in turn, recommends contextual vocabulary cards to the child. Through a two-week deployment study with 11 MVA child-parent dyads, we examine how AACessTalk fosters everyday conversation practice and mutual engagement. Our findings show high engagement from all dyads, leading to increased frequency of conversation and turn-taking. AACessTalk also encouraged parents to explore their own interaction strategies and empowered the children to have more agency in communication. We discuss the implications of designing technologies for balanced communication dynamics in parent-MVA child interaction."
    },
    {
        title: "DiaryMate : Understanding User Perceptions and Experience in Human-AI Collaboration for Personal Journaling",
        abstract: "With their generative capabilities, large language models (LLMs) have transformed the role of technological writing assistants from simple editors to writing collaborators. Such a transition emphasizes the need for understanding user perception and experience, such as balancing user intent and the involvement of LLMs across various writing domains in designing writing assistants. In this study, we delve into the less explored domain of personal writing, focusing on the use of LLMs in introspective activities. Specifically, we designed DiaryMate, a system that assists users in journal writing with LLM. Through a 10-day field study (N=24), we observed that participants used the diverse sentences generated by the LLM to reflect on their past experiences from multiple perspectives. However, we also observed that they are over-relying on the LLM, often prioritizing its emotional expressions over their own. Drawing from these findings, we discuss design considerations when leveraging LLMs in a personal writing practice."
    },
    {
        title: "MindfulDiary: Harnessing Large Language Model to Support Psychiatric Patients’ Journaling",
        abstract: "Large Language Models (LLMs) offer promising opportunities in mental health domains, although their inherent complexity and low controllability elicit concerns regarding their applicability in clinical settings. We present MindfulDiary, an LLM-driven journaling app that helps psychiatric patients document daily experiences through conversation. Designed in collaboration with mental health professionals, MindfulDiary takes a state-based approach to safely comply with the experts' guidelines while carrying on free-form conversations. Through a four-week field study involving 28 patients with major depressive disorder and five psychiatrists, we examined how MindfulDiary facilitates patients' journaling practice and clinical care. The study revealed that MindfulDiary supported patients in consistently enriching their daily records and helped clinicians better empathize with their patients through an understanding of their thoughts and daily contexts. Drawing on these findings, we discuss the implications of leveraging LLMs in the mental health domain, bridging the technical feasibility and their integration into clinical settings."
    },
    {
        title: "Feed-O-Meter: Fostering Design Feedback Skills through Role-playing Interactions with AI Mentee",
        abstract: "Effective feedback, including critique and evaluation, helps designers develop design concepts and refine their ideas, supporting informed decision-making throughout the iterative design process. However, in studio-based design courses, students often struggle to provide feedback due to a lack of confidence and fear of being judged, which limits their ability to develop essential feedback-giving skills. Recent advances in large language models (LLMs) suggest that role-playing with AI agents can let learners engage in multi-turn feedback without the anxiety of external judgment or the time constraints of real-world settings. Yet prior studies have raised concerns that LLMs struggle to behave like real people in role-play scenarios, diminishing the educational benefits of these interactions. Therefore, designing AI-based agents that effectively support learners in practicing and developing intellectual reasoning skills requires more than merely assigning the target persona's personality and role to the agent. By addressing these issues, we present Feed-O-Meter, a novel system that employs carefully designed LLM-based agents to create an environment in which students can practice giving design feedback. The system enables users to role-play as mentors, providing feedback to an AI mentee and allowing them to reflect on how that feedback impacts the AI mentee's idea development process. A user study (N=24) indicated that Feed-O-Meter increased participants' engagement and motivation through role-switching and helped them adjust feedback to  be more comprehensible for an AI mentee. Based on these findings, we dis- cuss future directions for designing systems to foster feedback skills in design education."
    },
    {
        title: "Coherent visual design through attribute-specific feedback: a hybrid approach to intelligent design agents",
        abstract: "The scope of visual design is expanding to promote products and services across digital communication platforms, but support for coherent design with style guides seems limited. Based on the literature on style, coherence, and design support tools with different levels of intelligence, we describe coherence in visual design and propose to integrate preset style guidelines and constraints into feedback interactions to support achieving visual coherence. After formative research with expert designers, we prototype a pseudo-AI design support tool to simulate attribute-specific feedback and conduct user research to probe how participants engage with feedback provided by a human wizard acting as an intelligent agent. We analyze patterns of feedback and types of reactions observed in participants' design processes and outcomes. We then discuss the implications of attribute-specific feedback to describe visual coherence as a meta-property of design, and intelligent agents that guide situational judgements about visual coherence through feedback interactions."
    }
];
// ==========================================
// END DATA EDITING SECTION
// ==========================================

const TAGS = [
    { label: "Problem", color: "#EF4444" },
    { label: "Method", color: "#3B82F6" },
    { label: "Result", color: "#10B981" },
    { label: "Insight", color: "#F59E0B" },
    { label: "Future Work", color: "#8B5CF6" }
];

export interface SeedOptions {
    targetUserId: string;
    tags: { label: string; color: string }[];
    includeHighlights: boolean;
    smartHighlights: boolean;
    randomizeTimestamps?: boolean;
    randomizeDeletions?: boolean;
    readingSpeed?: number; // Multiplier for duration (0.5 = fast, 1.5 = slow)
}

export async function createDummyUser() {
    let secondaryApp;
    try {
        // 1. Find next available test user
        const usersRef = collection(db, "users");
        const usersSnap = await getDocs(usersRef);
        const testUsers = usersSnap.docs.map(d => d.data().email);

        let nextNum = 1;
        const nums: number[] = [];

        testUsers.forEach(email => {
            const match = email.match(/^test(\d+)@test\.com$/);
            if (match) {
                nums.push(parseInt(match[1]));
            }
        });

        if (nums.length > 0) {
            nextNum = Math.max(...nums) + 1;
        }

        const email = `test${nextNum}@test.com`;
        const password = `1234test${nextNum}`;

        // 2. Create Auth User using secondary app
        const appName = "secondaryApp";
        const existingApps = getApps();
        secondaryApp = existingApps.find(app => app.name === appName) || initializeApp(firebaseConfig, appName);
        const secondaryAuth = getAuth(secondaryApp);

        let uid;
        try {
            const userCred = await createUserWithEmailAndPassword(secondaryAuth, email, password);
            uid = userCred.user.uid;
        } catch (error: any) {
            if (error.code === 'auth/email-already-in-use') {
                console.log(`User ${email} already exists in Auth, attempting login...`);
                const userCred = await signInWithEmailAndPassword(secondaryAuth, email, password);
                uid = userCred.user.uid;
            } else {
                throw error;
            }
        }

        // 3. Create User Document
        await setDoc(doc(db, "users", uid), {
            uid,
            email,
            role: "user",
            created_at: new Date().toISOString()
        });

        // 4. Seed Data with Randomized Tags
        // Define tag variations
        const tagVariations = {
            Problem: ["Problem", "Issue", "Challenge", "Gap", "Limitation"],
            Method: ["Method", "Approach", "Technique", "Strategy", "Design"],
            Result: ["Result", "Outcome", "Finding", "Performance", "Data"],
            Insight: ["Insight", "Takeaway", "Implication", "Note", "Idea"],
            FutureWork: ["Future Work", "Next Steps", "Future Direction", "Open Question"]
        };

        // Helper to pick random item
        const pick = (arr: string[]) => arr[Math.floor(Math.random() * arr.length)];

        // Helper to shift color slightly
        const shiftColor = (hex: string) => {
            // Simple logic: just return the base color for now to keep it harmonious, 
            // or maybe vary opacity/lightness if we had a color lib. 
            // Let's stick to the base colors but maybe swap them around? 
            // No, consistency is good. Let's just vary the labels.
            return hex;
        };

        const randomizedTags = [
            { label: pick(tagVariations.Problem), color: "#EF4444" },
            { label: pick(tagVariations.Method), color: "#3B82F6" },
            { label: pick(tagVariations.Result), color: "#10B981" },
            { label: pick(tagVariations.Insight), color: "#F59E0B" },
            { label: pick(tagVariations.FutureWork), color: "#8B5CF6" }
        ];

        await seedTestDatabase({
            targetUserId: uid,
            tags: randomizedTags,
            includeHighlights: true,
            smartHighlights: true,
            randomizeTimestamps: true,
            randomizeDeletions: true,
            readingSpeed: 0.5 + Math.random() // 0.5 to 1.5
        });

        // Cleanup
        await signOut(secondaryAuth);
        // We don't delete the app here to avoid issues if called rapidly, 
        // or we can delete it. Let's keep it or rely on garbage collection? 
        // Better to delete to be clean, but might cause "app already exists" race conditions if not careful.
        // For this tool, let's delete it.
        await deleteApp(secondaryApp);

        return { success: true, message: `Created user ${email}` };

    } catch (error: any) {
        console.error("Dummy user creation error:", error);
        if (secondaryApp) await deleteApp(secondaryApp).catch(() => { });
        return { success: false, message: error.message };
    }
}

export async function seedTestDatabase(options: SeedOptions) {
    try {
        const { targetUserId, tags, includeHighlights, smartHighlights, randomizeTimestamps, randomizeDeletions, readingSpeed } = options;

        // 1. Create Tags (if provided)
        const tagIds: string[] = [];
        const tagsRef = collection(db, "tags");

        if (tags.length > 0) {
            const existingTagsQuery = query(tagsRef, where("user_id", "==", targetUserId));
            const existingTagsSnap = await getDocs(existingTagsQuery);
            const existingTagLabels = new Set(existingTagsSnap.docs.map(d => d.data().label));

            for (const tag of tags) {
                if (!existingTagLabels.has(tag.label)) {
                    const docRef = await addDoc(tagsRef, {
                        ...tag,
                        user_id: targetUserId,
                        order: 0
                    });
                    tagIds.push(docRef.id);
                } else {
                    const existingTag = existingTagsSnap.docs.find(d => d.data().label === tag.label);
                    if (existingTag) tagIds.push(existingTag.id);
                }
            }
        }

        // 2. Upload Papers & Annotations using Batch
        const batch = writeBatch(db);
        const papersRef = collection(db, "papers");
        const annotationsRef = collection(db, "annotations");

        for (const paperData of PAPERS) {
            // Randomize Paper Creation Time (if requested)
            // Base time: somewhere in the last 30 days
            const baseTime = randomizeTimestamps
                ? new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000).getTime()
                : Date.now();

            // Check if paper already exists for this user
            const existingPaperQuery = query(
                papersRef,
                where("user_id", "==", targetUserId),
                where("title", "==", paperData.title)
            );
            const existingPaperSnap = await getDocs(existingPaperQuery);

            let paperDocRef;

            if (!existingPaperSnap.empty) {
                // Use existing paper
                paperDocRef = existingPaperSnap.docs[0].ref;
                console.log(`Paper already exists: ${paperData.title}`);
            } else {
                // Add New Paper
                paperDocRef = doc(papersRef);
                batch.set(paperDocRef, {
                    title: paperData.title,
                    abstract_text: paperData.abstract,
                    user_id: targetUserId,
                    created_at: new Date(baseTime).toISOString(),
                    order: 0
                });
            }

            // Add Annotations if requested and tags exist
            if (includeHighlights && tagIds.length > 0) {
                const abstractLower = paperData.abstract.toLowerCase();
                const abstractLength = paperData.abstract.length;
                const occupiedRanges: { start: number; end: number }[] = [];

                // Determine number of annotations based on length (approx 1 per 200 chars) + random
                const baseNum = Math.floor(abstractLength / 200);
                const numAnnotations = Math.max(3, baseNum + Math.floor(Math.random() * 3));

                // Calculate TOTAL reading time for this paper (once)
                // Base: 1 min per 500 chars
                // Variance: 0.8x to 1.2x per paper
                // User Speed: Multiplier passed from options
                const baseDuration = (abstractLength / 500) * 60 * 1000;
                const variance = 0.8 + (Math.random() * 0.4);
                const userFactor = readingSpeed || 1;
                const totalReadingTime = Math.max(10 * 1000, baseDuration * variance * userFactor); // Min 10 seconds

                // Paper base time for this user's reading session
                const paperBaseTime = randomizeTimestamps
                    ? new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000).getTime()
                    : Date.now();

                for (let i = 0; i < numAnnotations; i++) {
                    let randomTagId = tagIds[Math.floor(Math.random() * tagIds.length)];
                    let start = 0;
                    let end = 0;
                    let textContent = "";
                    let attempts = 0;
                    const maxAttempts = 10;
                    let validRangeFound = false;

                    while (attempts < maxAttempts && !validRangeFound) {
                        attempts++;
                        start = 0;
                        end = 0;
                        textContent = "";

                        // Smart Heuristic Logic
                        if (smartHighlights) {
                            const tagIndex = tagIds.indexOf(randomTagId);
                            const tagLabel = tags[tagIndex]?.label.toLowerCase() || "";

                            let keywords: string[] = [tagLabel];
                            if (tagLabel.includes("method")) keywords.push("use", "propose", "design", "develop");
                            if (tagLabel.includes("result")) keywords.push("show", "find", "reveal", "indicate");
                            if (tagLabel.includes("problem")) keywords.push("issue", "challenge", "struggle", "limit");
                            if (tagLabel.includes("future")) keywords.push("future", "discuss", "implication");

                            const sentences = paperData.abstract.match(/[^.!?]+[.!?]+/g) || [paperData.abstract];
                            const matchingSentences = sentences.filter(s => keywords.some(k => s.toLowerCase().includes(k)));

                            if (matchingSentences.length > 0) {
                                const targetSentence = matchingSentences[Math.floor(Math.random() * matchingSentences.length)];
                                textContent = targetSentence.trim();
                                start = paperData.abstract.indexOf(targetSentence);
                                end = start + textContent.length;
                            }
                        }

                        // Fallback to random if smart logic failed or didn't run
                        if (end === 0) {
                            let randStart = Math.floor(Math.random() * (abstractLength - 15));
                            let length = Math.floor(Math.random() * 50) + 10;
                            if (randStart < 0) randStart = 0;
                            let randEnd = randStart + length;
                            if (randEnd > abstractLength) randEnd = abstractLength;

                            start = randStart;
                            end = randEnd;
                            textContent = paperData.abstract.substring(start, end);
                        }

                        // Expand to Word Boundary
                        if (end > start) {
                            // Expand start left
                            while (start > 0 && /\w/.test(paperData.abstract[start - 1])) {
                                start--;
                            }
                            // Expand end right
                            while (end < abstractLength && /\w/.test(paperData.abstract[end])) {
                                end++;
                            }
                            textContent = paperData.abstract.substring(start, end);
                        }

                        // Check for overlap with GAP (e.g., 2 chars) to prevent touching highlights
                        const GAP = 2;
                        const isOverlapping = occupiedRanges.some(range =>
                            (start < range.end + GAP && end > range.start - GAP)
                        );

                        if (!isOverlapping && end > start && textContent.trim().length > 0) {
                            validRangeFound = true;
                            occupiedRanges.push({ start, end });
                        }
                    }

                    if (!validRangeFound) continue; // Skip if no valid range found after retries

                    // Spread annotations across the total reading time
                    // First annotation starts at paperBaseTime
                    // Last annotation ends at paperBaseTime + totalReadingTime
                    // Annotations are spread evenly with some randomness
                    let createdTime = Date.now();
                    let updatedTime = Date.now();

                    if (randomizeTimestamps) {
                        // Progress through the paper (0 to 1)
                        const progress = i / Math.max(1, numAnnotations - 1);
                        // Add some randomness to the progress (±10%)
                        const randomOffset = (Math.random() - 0.5) * 0.2;
                        const adjustedProgress = Math.max(0, Math.min(1, progress + randomOffset));

                        createdTime = paperBaseTime + (adjustedProgress * totalReadingTime);
                        // Updated time is just slightly after created (1-5 seconds for editing)
                        updatedTime = createdTime + (1000 + Math.random() * 4000);
                    }

                    // Randomize Deletion
                    let deletedAt = undefined;
                    if (randomizeDeletions && Math.random() < 0.3) { // 30% chance
                        deletedAt = new Date(updatedTime + 1000).toISOString();
                    }

                    const annotationDocRef = doc(annotationsRef);
                    batch.set(annotationDocRef, {
                        paper_id: paperDocRef.id,
                        user_id: targetUserId,
                        tag_id: randomTagId,
                        text_content: textContent,
                        start_index: start,
                        end_index: end,
                        created_at: new Date(createdTime).toISOString(),
                        updated_at: new Date(updatedTime).toISOString(),
                        ...(deletedAt ? { deleted_at: deletedAt } : {})
                    });
                }
            }
        }

        await batch.commit();

        // 3. Create Paper Sessions (for time tracking)
        const sessionsRef = collection(db, "paper_sessions");
        const sessionBatch = writeBatch(db);

        // Get all papers we just created for this user
        const userPapersQuery = query(papersRef, where("user_id", "==", targetUserId));
        const userPapersSnap = await getDocs(userPapersQuery);

        userPapersSnap.docs.forEach(paperDoc => {
            const paperData = PAPERS.find(p => p.title === paperDoc.data().title);
            if (!paperData) return;

            const abstractLength = paperData.abstract.length;

            // Calculate realistic reading time based on length
            // Base: 2-5 minutes per 500 chars
            // Apply user reading speed factor
            const baseDuration = (abstractLength / 500) * (2 + Math.random() * 3) * 60; // 2-5 mins in seconds
            const userFactor = readingSpeed || 1;
            const variance = 0.8 + (Math.random() * 0.4); // 0.8x to 1.2x
            const totalDuration = Math.max(30, baseDuration * userFactor * variance); // Min 30 seconds

            // Random time in the past 30 days
            const sessionStart = new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000);

            // Create single session document per paper
            const sessionDocRef = doc(sessionsRef);
            sessionBatch.set(sessionDocRef, {
                user_id: targetUserId,
                paper_id: paperDoc.id,
                start_time: sessionStart.toISOString(),
                last_updated: new Date().toISOString(),
                duration_seconds: Math.floor(totalDuration)
            });
        });

        await sessionBatch.commit();

        return { success: true, message: `Seeding complete for user ID: ${targetUserId}` };

    } catch (error: any) {
        console.error("Seeding error:", error);
        return { success: false, message: error.message };
    }
}
